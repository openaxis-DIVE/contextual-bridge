const DEBUG = true;

function log(...args) {
  if (DEBUG) {
    const timestamp = new Date().toLocaleTimeString('en-US', {
      hour12: false,
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      fractionalSecondDigits: 3
    });
    console.log(`[${timestamp}] [Background]`, ...args);
  }
}

// ============================================================================
// FileMarkerParser - Inlined for service worker compatibility
// ============================================================================

class FileMarkerParser {
  constructor() {
    this.patterns = [
      { name: 'json', regex: /\{\s*"\$file"\s*:\s*"([^"]+)"/ },
      { name: 'comment', regex: /^[\s\/\*\#\[\<\-'"`]*\s*(.+?)\s*$/ }
    ];
  }

  parse(text) {
    if (!text || text.length === 0) return null;

    const firstLine = text.trimStart().split('\n')[0];
    const filepath = this.extractPath(firstLine);

    if (!filepath || !this.isValidPath(filepath)) {
      return null;
    }

    const content = text.split('\n').slice(1).join('\n').trim();
    if (!content) {
      return null;
    }

    return { filepath, content };
  }

  extractPath(line) {
    for (const pattern of this.patterns) {
      const match = line.match(pattern.regex);
      if (match?.[1]) {
        return match[1];
      }
    }
    return null;
  }

  isValidPath(path) {
    return /\.\w+$|[\/\\]/.test(path);
  }
}

log('‚úÖ FileMarkerParser loaded (inlined)');

// ============================================================================
// Track offscreen document readiness
// ============================================================================

let offscreenReady = false;
let offscreenPath = 'offscreen.html';

// ============================================================================
// Offscreen Document Management
// ============================================================================

async function ensureOffscreen() {
  if (offscreenReady) {
    return;
  }

  try {
    // Check if offscreen document already exists
    const offscreenUrl = chrome.runtime.getURL(offscreenPath);
    const existingContexts = await chrome.runtime.getContexts({
      contextTypes: ['OFFSCREEN_DOCUMENT'],
      documentUrls: [offscreenUrl]
    });

    if (existingContexts.length > 0) {
      offscreenReady = true;
      log('‚úÖ Offscreen document already exists');
      return;
    }

    // Create offscreen document
    await chrome.offscreen.createDocument({
      url: offscreenPath,
      reasons: ['DOM_PARSER'],
      justification: 'File System Access API'
    });

    offscreenReady = true;
    log('‚úÖ Offscreen document created');
  } catch (error) {
    log('‚ùå Offscreen creation error:', error.message);
    offscreenReady = false;
  }
}

// Listen for offscreen readiness signal
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  if (message.action === 'OFFSCREEN_READY') {
    offscreenReady = true;
    log('‚úÖ Offscreen reported ready');
    sendResponse({ success: true });
  }
});

// ============================================================================
// Message Handlers (Handler Map)
// ============================================================================

const messageHandlers = {
  // Legacy action (backward compatibility)
  'saveFile': handleSaveFile_Legacy,

  // Phase 1: KeyHandler actions
  'OPEN_MODAL': handleOpenModal,
  'CLOSE_MODAL': handleCloseModal,
  'SAVE_FILE': handleSaveFile,
  'LOAD_FILE': handleLoadFile,
  'PICK_DIRECTORY': handlePickDirectory,

  // Offscreen logging
  'LOG_RELAY_FROM_OFFSCREEN': handleLogRelay
};

/**
 * Default handler for unknown actions
 * @param {string} action - The action name
 * @param {*} payload - The message payload
 * @param {object} sender - The message sender
 * @param {function} sendResponse - Response callback
 */
function handleUnknownAction(action, payload, sender, sendResponse) {
  log('‚ö†Ô∏è Unknown action:', action);
  sendResponse({ error: `Unknown action: ${action}` });
}

// ============================================================================
// Message Routing (Object Lookup Pattern)
// ============================================================================

chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  const { action, payload } = message;
  log(`üì® Received: ${action}`, payload);

  // Look up handler or use default
  const handler = messageHandlers[action] || handleUnknownAction;

  // Call handler with correct signature (action, payload, sender, sendResponse)
  handler(action, payload, sender, sendResponse);

  // Return true to indicate async response
  return true;
});

// ============================================================================
// Helper: Call offscreen ENSURE_DIRECTORY
// ============================================================================

async function ensureDirectoryViaOffscreen() {
  await ensureOffscreen();
  return new Promise((resolve, reject) => {
    chrome.runtime.sendMessage(
      { action: 'ENSURE_DIRECTORY' },
      (response) => {
        if (chrome.runtime.lastError) {
          log('‚ùå ENSURE_DIRECTORY error:', chrome.runtime.lastError.message);
          reject(new Error(chrome.runtime.lastError.message));
          return;
        }

        resolve(response || { success: false });
      }
    );
  });
}

// ============================================================================
// Handler Functions
// ============================================================================

/**
 * Legacy: Save file via offscreen document
 */
function handleSaveFile_Legacy(action, payload, sender, sendResponse) {
  const { filepath, content } = payload;
  const filename = filepath.split(/[\/\\]/).pop();
  log(`üíæ Save file (legacy): ${filename}`);

  ensureOffscreen().then(() => {
    chrome.runtime.sendMessage({
      action: 'WRITE_FILE',
      filepath,
      content
    }, (response) => {
      if (chrome.runtime.lastError) {
        log(`‚ùå Write error: ${chrome.runtime.lastError.message}`);
        sendResponse({ success: false, error: chrome.runtime.lastError.message });
        return;
      }

      if (response?.success) {
        log(`‚úÖ Saved (legacy): ${filename}`);
        sendResponse({ success: true });
      } else {
        log(`‚ùå Save failed (legacy): ${response?.error}`);
        sendResponse({ success: false, error: response?.error });
      }
    });
  });
}

/**
 * Phase 1: Open modal
 * - Ensure directory via offscreen
 * - Persist dirName in chrome.storage.local
 */
function handleOpenModal(action, payload, sender, sendResponse) {
  log('üéØ Opening modal');

  ensureDirectoryViaOffscreen()
    .then((result) => {
      if (result.success && result.dirName) {
        // Persist directory name for future sessions
        chrome.storage.local.set({ dirName: result.dirName }, () => {
          log('üìÅ Directory ready:', result.dirName);
          sendResponse({
            success: true,
            dirName: result.dirName
          });
        });
      } else if (result.cancelled) {
        log('‚ö†Ô∏è User cancelled directory picker');
        sendResponse({
          success: false,
          cancelled: true,
          error: 'Directory picker cancelled'
        });
      } else {
        log('‚ùå Failed to ensure directory:', result.error);
        sendResponse({
          success: false,
          error: result.error || 'Failed to ensure directory'
        });
      }
    })
    .catch((err) => {
      log('üí• ensureDirectoryViaOffscreen error:', err.message);
      sendResponse({
        success: false,
        error: err.message
      });
    });
}

/**
 * Phase 1: Close modal
 */
function handleCloseModal(action, payload, sender, sendResponse) {
  log('üéØ Closing modal');
  // Simple acknowledgment - KeyHandler manages listeningMode state
  sendResponse({ success: true });
}

/**
 * Phase 1: Save file from KeyHandler
 * NOW IMPLEMENTED: Parse content, ensure directory, forward to offscreen
 */
function handleSaveFile(action, payload, sender, sendResponse) {
  const { content } = payload;
  log(`üíæ Save file (KeyHandler): ${content?.length || 0} bytes`);

  // Step 1: Parse content using FileMarkerParser (now inlined)
  const parser = new FileMarkerParser();
  const parsed = parser.parse(content);

  if (!parsed || !parsed.filepath || !parsed.content) {
    log('‚ùå Could not parse filepath marker from content');
    sendResponse({
      success: false,
      error: 'Could not detect filepath marker in clipboard content'
    });
    return;
  }

  const { filepath, content: body } = parsed;
  log(`üìù Parsed filepath: ${filepath}`);

  // Step 2: Ensure directory via offscreen
  ensureDirectoryViaOffscreen()
    .then((dirResult) => {
      if (!dirResult.success) {
        if (dirResult.cancelled) {
          log('‚ö†Ô∏è Directory picker cancelled during save');
          sendResponse({
            success: false,
            cancelled: true,
            error: 'Directory picker cancelled'
          });
        } else {
          log('‚ùå Failed to ensure directory:', dirResult.error);
          sendResponse({
            success: false,
            error: dirResult.error || 'Failed to ensure directory'
          });
        }
        return;
      }

      // Step 3: Forward to offscreen saveFile handler (legacy action)
      ensureOffscreen().then(() => {
        chrome.runtime.sendMessage(
          { action: 'saveFile', filepath, content: body },
          (saveResponse) => {
            if (chrome.runtime.lastError) {
              log('‚ùå Offscreen saveFile error:', chrome.runtime.lastError.message);
              sendResponse({
                success: false,
                error: chrome.runtime.lastError.message
              });
              return;
            }

            if (saveResponse?.success) {
              log(`‚úÖ File saved: ${filepath}`);
              sendResponse({
                success: true,
                filepath
              });
            } else {
              log(`‚ùå Save failed: ${saveResponse?.error}`);
              sendResponse({
                success: false,
                error: saveResponse?.error || 'Unknown save error'
              });
            }
          }
        );
      });
    })
    .catch((err) => {
      log('üí• Save file error:', err.message);
      sendResponse({
        success: false,
        error: err.message
      });
    });
}

/**
 * Phase 1: Load file from KeyHandler
 * NOTE: Still placeholder - deferred to Phase 2
 */
function handleLoadFile(action, payload, sender, sendResponse) {
  const { selectedText } = payload;
  log(`üìÇ Load file (KeyHandler): ${selectedText || 'no selection'}`);

  // TODO: Phase 2 - implement LOAD_FILE via offscreen
  sendResponse({
    success: false,
    error: 'Not implemented yet - deferred to Phase 2'
  });
}

/**
 * Phase 1: Pick working directory
 * - Force re-run of ENSURE_DIRECTORY via offscreen
 */
function handlePickDirectory(action, payload, sender, sendResponse) {
  log('üìÅ Pick directory (KeyHandler)');

  // Force a fresh ENSURE_DIRECTORY
  ensureDirectoryViaOffscreen()
    .then((result) => {
      if (result.success && result.dirName) {
        chrome.storage.local.set({ dirName: result.dirName }, () => {
          log('üìÅ Directory re-selected:', result.dirName);
          sendResponse({
            success: true,
            dirName: result.dirName
          });
        });
      } else if (result.cancelled) {
        log('‚ö†Ô∏è User cancelled directory picker (PICK_DIRECTORY)');
        sendResponse({
          success: false,
          cancelled: true,
          error: 'Directory picker cancelled'
        });
      } else {
        log('‚ùå Failed to pick directory:', result.error);
        sendResponse({
          success: false,
          error: result.error || 'Failed to pick directory'
        });
      }
    })
    .catch((err) => {
      log('üí• ensureDirectoryViaOffscreen (PICK_DIRECTORY) error:', err.message);
      sendResponse({
        success: false,
        error: err.message
      });
    });
}

/**
 * Relay log messages from offscreen document
 */
function handleLogRelay(action, payload, sender, sendResponse) {
  const { args } = payload || {};
  log('üì° [Offscreen]', ...(args || []));
  sendResponse({ success: true });
}

// ============================================================================
// Initialization
// ============================================================================

log('üöÄ Background service worker initialized');

// Attempt to ensure offscreen on startup
ensureOffscreen().catch(err => {
  log('‚ö†Ô∏è Offscreen startup warning:', err.message);
});